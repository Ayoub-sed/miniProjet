var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import IntlRelativeFormat from 'intl-relativeformat';
import * as formatters from '../formatters';
import { escape, filterProps } from '../utils';
import { Observable } from 'rxjs/Observable';
import { Injectable } from '@angular/core';
import { IntlService } from './intl.service';
import { DATE_TIME_FORMAT_OPTIONS, RELATIVE_FORMAT_OPTIONS, RELATIVE_FORMAT_THRESHOLDS, NUMBER_FORMAT_OPTIONS, PLURAL_FORMAT_OPTIONS } from './format';
import { debug } from '../debug';
function updateRelativeFormatThresholds(newThresholds) {
    var thresholds = IntlRelativeFormat.thresholds;
    (thresholds.second = newThresholds.second, thresholds.minute = newThresholds.minute, thresholds.hour = newThresholds.hour, thresholds.day = newThresholds.day, thresholds.month = newThresholds.month);
}
function getNamedFormat(formats, type, name) {
    var format = formats && formats[type] && formats[type][name];
    if (format) {
        return format;
    }
    debug("[Ng2 Intl] No " + type + " format named: " + name);
}
var FormatService = /** @class */ (function () {
    function FormatService(intlService) {
        this.intlService = intlService;
    }
    FormatService.prototype.formatDate = function (value, options) {
        if (options === void 0) { options = {}; }
        var _a = this.intlService.getConfig(), locale = _a.locale, formats = _a.formats;
        var format = options.format;
        var date = value instanceof Date ? value : new Date(value);
        var defaults = format && getNamedFormat(formats, 'date', format);
        var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
        try {
            return formatters.getDateTimeFormat(locale, filteredOptions).format(date);
        }
        catch (e) {
            debug("[Ng2 Intl] Error formatting date.\n" + e);
        }
        return String(date);
    };
    FormatService.prototype.formatTime = function (value, options) {
        if (options === void 0) { options = {}; }
        var _a = this.intlService.getConfig(), locale = _a.locale, formats = _a.formats;
        var format = options.format;
        var date = value instanceof Date ? value : new Date(value);
        var defaults = format && getNamedFormat(formats, 'time', format);
        var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
        if (!filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second) {
            // Add default formatting options if hour, minute, or second isn't defined.
            filteredOptions = Object.assign({}, filteredOptions, {
                hour: 'numeric',
                minute: 'numeric'
            });
        }
        try {
            return formatters.getDateTimeFormat(locale, filteredOptions).format(date);
        }
        catch (e) {
            debug("[Ng2 Intl] Error formatting time.\n" + e);
        }
        return String(date);
    };
    FormatService.prototype.formatRelative = function (value, options) {
        if (options === void 0) { options = {}; }
        var _a = this.intlService.getConfig(), formats = _a.formats, locale = _a.locale;
        var format = options.format;
        var date = value instanceof Date ? value : new Date(value);
        var now = new Date();
        var defaults = format && getNamedFormat(formats, 'relative', format);
        var filteredOptions = filterProps(options, RELATIVE_FORMAT_OPTIONS, defaults);
        // Capture the current threshold values, then temporarily override them with
        // specific values just for this render.
        var oldThresholds = Object.assign({}, IntlRelativeFormat.thresholds);
        updateRelativeFormatThresholds(RELATIVE_FORMAT_THRESHOLDS);
        try {
            return formatters.getRelativeFormat(locale, filteredOptions).format(date, {
                now: now
            });
        }
        catch (e) {
            debug("[Ng2 Intl] Error formatting relative time.\n" + e);
        }
        finally {
            updateRelativeFormatThresholds(oldThresholds);
        }
        return String(date);
    };
    FormatService.prototype.formatNumber = function (value, options) {
        if (options === void 0) { options = {}; }
        var _a = this.intlService.getConfig(), formats = _a.formats, locale = _a.locale;
        var format = options.format;
        var defaults = format && getNamedFormat(formats, 'number', format);
        var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
        try {
            return formatters.getNumberFormat(locale, filteredOptions).format(value);
        }
        catch (e) {
            debug("[Ng2 Intl] Error formatting number.\n" + e);
        }
        return String(value);
    };
    FormatService.prototype.formatPlural = function (value, options) {
        if (options === void 0) { options = {}; }
        var locale = this.intlService.getConfig().locale;
        var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
        try {
            return formatters.getPluralFormat.bind(null)(locale, filteredOptions).format(value);
        }
        catch (e) {
            debug("[Ng2 Intl] Error formatting plural.\n" + e);
        }
        return 'other';
    };
    FormatService.prototype.formatMessageAsync = function (descriptor, values) {
        var _this = this;
        if (values === void 0) { values = {}; }
        var id = descriptor.id;
        return Observable.create(function (observer) {
            _this.intlService.getAsync(id)
                .subscribe(function (message) {
                observer.next(_this.processFormatMessage(message, descriptor, values));
                observer.complete();
            });
        });
    };
    FormatService.prototype.formatMessage = function (descriptor, values) {
        if (values === void 0) { values = {}; }
        var id = descriptor.id;
        var message = this.intlService.get(id);
        return this.processFormatMessage(message, descriptor, values);
    };
    FormatService.prototype.processFormatMessage = function (message, descriptor, values) {
        if (values === void 0) { values = {}; }
        var _a = this.intlService.getConfig(), formats = _a.formats, locale = _a.locale, defaultLocale = _a.defaultLocale;
        var id = descriptor.id, defaultMessage = descriptor.defaultMessage;
        var hasValues = Object.keys(values).length > 0;
        // Avoid expensive message formatting for simple messages without values. In
        // development messages will always be formatted in case of missing values.
        if (!hasValues) {
            return message || defaultMessage || id;
        }
        var formattedMessage;
        var defaultFormattedMessage;
        if (message) {
            try {
                var formatter = formatters.getMessageFormat(message, locale, formats);
                formattedMessage = formatter.format(values);
            }
            catch (e) {
                debug("[Ng2 Intl] Error formatting message: \"" + id + "\" for locale: \"" + locale + "\"" +
                    (defaultMessage ? ', using default message as fallback.' : '') +
                    ("\n" + e));
            }
        }
        else {
            if (!defaultMessage ||
                (locale && defaultLocale && locale.toLowerCase() !== defaultLocale.toLowerCase())) {
                debug("[Ng2 Intl] Missing message: \"" + id + "\" for locale: \"" + locale + "\"" +
                    (defaultMessage ? ', using default message as fallback.' : ''));
            }
        }
        if (!formattedMessage && defaultMessage) {
            try {
                var formatter = formatters.getMessageFormat(defaultMessage, defaultLocale, formats);
                defaultFormattedMessage = formatter.format(values);
            }
            catch (e) {
                debug("[Ng2 Intl] Error formatting the default message for: \"" + id + "\"" +
                    ("\n" + e));
            }
        }
        if (!defaultFormattedMessage && typeof formattedMessage !== 'string') {
            debug("[Ng2 Intl] Cannot format message: \"" + id + "\", " +
                ("using message " + (message || defaultMessage ? 'source' : 'id') + " as fallback."));
        }
        if (formattedMessage) {
            return formattedMessage;
        }
        return defaultFormattedMessage || typeof formattedMessage === 'string' ? formattedMessage : message || defaultMessage || id;
    };
    FormatService.prototype.formatHTMLMessage = function (descriptor, rawValues) {
        if (rawValues === void 0) { rawValues = {}; }
        var escapedValues = this.escapeValues(rawValues);
        return this.formatMessage(descriptor, escapedValues);
    };
    FormatService.prototype.formatHTMLMessageAsync = function (descriptor, rawValues) {
        if (rawValues === void 0) { rawValues = {}; }
        var escapedValues = this.escapeValues(rawValues);
        return this.formatMessageAsync(descriptor, escapedValues);
    };
    FormatService.prototype.escapeValues = function (rawValues) {
        if (rawValues === void 0) { rawValues = {}; }
        // Process all the values before they are used when formatting the ICU
        // Message string. Since the formatted message might be injected via
        // `innerHTML`, all String-based values need to be HTML-escaped.
        return Object.keys(rawValues).reduce(function (escaped, name) {
            var value = rawValues[name];
            escaped[name] = typeof value === 'string' ? escape(value) : value;
            return escaped;
        }, {});
    };
    FormatService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [IntlService])
    ], FormatService);
    return FormatService;
}());
export { FormatService };
//# sourceMappingURL=format.service.js.map