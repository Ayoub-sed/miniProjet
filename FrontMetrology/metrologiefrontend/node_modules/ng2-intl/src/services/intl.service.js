var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Injectable, Optional, EventEmitter } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { IntlLoader } from './intl.loader';
import { debug } from '../debug';
import get from 'lodash-es/get';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/merge';
import 'rxjs/add/operator/toArray';
var MissingTranslationHandler = /** @class */ (function () {
    function MissingTranslationHandler() {
    }
    return MissingTranslationHandler;
}());
export { MissingTranslationHandler };
var IntlService = /** @class */ (function () {
    function IntlService(currentLoader, missingTranslationHandler) {
        this.currentLoader = currentLoader;
        this.missingTranslationHandler = missingTranslationHandler;
        /**
         * An EventEmitter to listen to lang change events
         * onLangChange.subscribe((params: LangChangeEvent) => {
         *     // do something
         * });
         * @type {ng.EventEmitter<LangChangeEvent>}
         */
        this.onLangChange = new EventEmitter();
        this.messages = {};
        this.defaultFormat = {};
        this.langs = [];
    }
    /**
       * Sets the default language to use as a fallback
       * @param lang
       */
    IntlService.prototype.setDefaultLang = function (lang) {
        this.defaultLang = lang;
    };
    /**
       * Gets the default language used
       * @returns string
       */
    IntlService.prototype.getDefaultLang = function () {
        return this.defaultLang;
    };
    IntlService.prototype.start = function () {
        if (typeof this.messages[this.defaultLang] === 'undefined') {
            // not available, ask for it
            this.getTranslation(this.defaultLang);
            if (!this.currentLang) {
                this.currentLang = this.defaultLang;
            }
        }
    };
    /**
     * Changes the lang currently used
     * @param lang
     * @returns {Observable<*>}
     */
    IntlService.prototype.use = function (lang) {
        var _this = this;
        var pending;
        // check if this language is available
        if (typeof this.messages[lang] === 'undefined') {
            // not available, ask for it
            pending = this.getTranslation(lang);
        }
        if (typeof pending !== 'undefined') {
            // on init set the currentLang immediately
            if (!this.currentLang) {
                this.currentLang = lang;
            }
            pending.subscribe(function (res) {
                _this.changeLang(lang);
            });
            return pending;
        }
        else {
            this.changeLang(lang);
            return Observable.of(this.messages[lang]);
        }
    };
    /**
     * Gets an object of messages for a given language with the current loader
     * @param lang
     * @returns {Observable<*>}
     */
    IntlService.prototype.getTranslation = function (lang) {
        var _this = this;
        this.pending = this.currentLoader.getMessages(lang).share();
        this.pending.subscribe(function (res) {
            _this.messages[lang] = res;
            _this.updateLangs();
        }, function (err) {
            throw err;
        }, function () {
            _this.pending = undefined;
        });
        return this.pending;
    };
    /**
      * Manually sets an object of translations for a given language
      * @param lang
      * @param translations
      * @param shouldMerge
      */
    IntlService.prototype.setTranslation = function (lang, translations, shouldMerge) {
        if (shouldMerge === void 0) { shouldMerge = false; }
        if (shouldMerge && this.messages[lang]) {
            Object.assign(this.messages[lang], translations);
        }
        else {
            this.messages[lang] = translations;
        }
        this.updateLangs();
    };
    /**
       * Returns an array of currently available langs
       * @returns {any}
       */
    IntlService.prototype.getLangs = function () {
        return this.langs;
    };
    /**
  * @param langs
  * Add available langs
  */
    IntlService.prototype.addLangs = function (langs) {
        var _this = this;
        langs.forEach(function (lang) {
            if (_this.langs.indexOf(lang) === -1) {
                _this.langs.push(lang);
            }
        });
    };
    /**
     * Update the list of available langs
     */
    IntlService.prototype.updateLangs = function () {
        this.addLangs(Object.keys(this.messages));
    };
    /**
       * Gets the message of a key
       * @param key
       * @returns {any} the translated key
       */
    IntlService.prototype.getAsync = function (key) {
        var _this = this;
        if (!key) {
            throw new Error("Parameter \"key\" required");
        }
        var obs;
        // check if we are loading a new translation to use
        if (this.pending) {
            obs = Observable.create(function (observer) {
                _this.pending.subscribe(function (res) {
                    observer.next(get(res, key, undefined));
                    observer.complete();
                });
            });
        }
        else {
            obs = Observable.of(get(this.messages[this.currentLang], key, undefined));
        }
        return Observable.create(function (observer) {
            obs.subscribe(function (res) {
                if (typeof res === 'undefined' && _this.defaultLang && _this.defaultLang !== _this.currentLang) {
                    res = get(_this.messages[_this.defaultLang], key, undefined);
                    debug("[Ng Intl] Error formatting message: \"" + key + "\" for locale: \"" + _this.currentLang + "\", using default message as fallback.");
                }
                if (!res && _this.missingTranslationHandler) {
                    res = _this.missingTranslationHandler.handle(key);
                }
                observer.next(res);
                observer.complete();
            });
        });
    };
    /**
      * Gets the message of a key
      * @param key
      * @returns {any} the translated key
      */
    IntlService.prototype.get = function (key) {
        if (!key) {
            throw new Error("Parameter \"key\" required");
        }
        var res = get(this.messages[this.currentLang], key, this.messages[this.currentLang][key]);
        if (typeof res === 'undefined' && this.defaultLang && this.defaultLang !== this.currentLang) {
            res = get(this.messages[this.defaultLang], key, this.messages[this.defaultLang][key]);
            debug("[Ng Intl] Error formatting message: \"" + key + "\" for locale: \"" + this.currentLang + "\", using default message as fallback.");
        }
        if (!res && this.missingTranslationHandler) {
            res = this.missingTranslationHandler.handle(key);
        }
        return res;
    };
    IntlService.prototype.getConfig = function () {
        return {
            locale: this.currentLang,
            formats: this.defaultFormat,
            defaultLocale: this.defaultLang
        };
    };
    /**
     * Changes the current lang
     * @param lang
     */
    IntlService.prototype.changeLang = function (lang) {
        this.currentLang = lang;
        this.onLangChange.emit({ lang: lang, messages: this.messages[lang] });
    };
    IntlService = __decorate([
        Injectable(),
        __param(1, Optional()),
        __metadata("design:paramtypes", [IntlLoader, MissingTranslationHandler])
    ], IntlService);
    return IntlService;
}());
export { IntlService };
//# sourceMappingURL=intl.service.js.map